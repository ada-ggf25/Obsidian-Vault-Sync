#computer_theory #computer_science #python 

PEP 518 defines **`pyproject.toml`** and how Python packaging tools should use it.

## What it does (in practice)

- Introduces a **standard file**: `pyproject.toml`.
- Lets a project declare **how to build itself** (which build backend and which build-time deps).
- Allows installers (e.g., `pip`) to create an **isolated build env** with those deps before building wheels/sdists.

## Minimal example

```toml
# pyproject.toml
[build-system]
requires = ["setuptools>=61", "wheel"]  # build-time deps
build-backend = "setuptools.build_meta" # the build backend

```

Other common backends:

- `"flit_core.buildapi"`
- `"hatchling.build"`
- `"poetry.core.masonry.api"`

Then:

```bash
pip wheel .          # pip reads pyproject, builds in isolation
pip install .        # same idea

```

## Why it matters

- Decouples packaging from legacy `distutils` and hard-coded `setuptools`.
- Enables alternative backends (Flit, Hatchling, Poetry).
- More reproducible builds via **build isolation**.

## Related (good to know)

- **PEP 517**: defines the _hook interface_ for build backends (goes hand-in-hand with 518).
- **PEP 621**: standardizes **project metadata** (name, version, deps) inside `pyproject.toml`—so you can often drop `setup.py`/`setup.cfg`.

## Extra tips

- Configure tools under `[tool.X]`, e.g.:
    
    ```toml
    [tool.black]
    line-length = 100
    
    ```
    
- If needed, disable build isolation: `pip install . --no-build-isolation` (not typical).
    

If you tell me your backend (setuptools, Hatch, Poetry, Flit), I’ll sketch a ready-to-use `pyproject.toml` for your project.