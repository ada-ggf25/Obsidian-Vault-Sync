Great question! Those are **IPython/Jupyter shortcuts**, not standard Python.

# Inside a Jupyter notebook (or IPython)

## `!` — run a **shell command**

Runs the command in your OS shell from the current notebook directory.

```python
!ls              # list files
!python script.py arg1
!grep -n "TODO" *.py

```

Extras you get in IPython:

- Capture output:
    
    ```python
    files = !ls
    print(files)        # an SList (list-like) of lines
    
    ```
    
- Use Python vars in commands:
    
    ```python
    fname = "data.csv"
    !wc -l {fname}
    
    ```
    

## `%` — **line magic** (and `%%` for **cell magic**)

Special IPython commands that augment Python. A few handy ones:

```python
%pwd              # print working dir
%cd src           # change dir for this kernel
%timeit f(x)      # benchmark an expression
%env VAR=value    # set environment variable
%run script.py    # run a .py file in this kernel
%pip install xyz  # install into the *current kernel*

```

Cell magics (`%%`) act on the whole cell:

```python
%%time
# times everything in the cell

%%bash
echo "this whole cell runs as a bash script"

```

> Tip: Use %pip instead of !pip in notebooks; it ensures packages install into the kernel you’re using.

---

# Outside a notebook

- In the **standard Python REPL** or a `.py` script, `%`/`%%`/`!` are **syntax errors**. They only work in IPython/Jupyter.
- In a **regular shell** (bash, zsh, PowerShell), you **don’t** need `!` to run commands; you just type `ls`, `python script.py`, etc. (In bash, `!` is used for history expansion, not for running commands.)

---

# “Without them” — pure Python equivalents

If you’re writing normal Python (script/module) and need the same effects:

**Run shell commands** → use `subprocess`:

```python
import subprocess

subprocess.run(["ls", "-l"])                     # no capture
out = subprocess.run(["python", "script.py"], capture_output=True, text=True)
print(out.stdout)

```

**Change directory / paths** → `os` / `pathlib`:

```python
import os, pathlib
print(os.getcwd())
os.chdir("src")
for p in pathlib.Path(".").glob("*.py"): print(p)

```

**Measure time** → `timeit`:

```python
import timeit
print(timeit.timeit("f(x)", globals=globals(), number=1000))

```

**Run another Python file** → import it or use `runpy`:

```python
import runpy
runpy.run_path("script.py")   # like %run

```

**Set env vars** → `os.environ`:

```python
import os
os.environ["VAR"] = "value"

```

---

## When to use which

- **Exploration / notebooks** → `!` and `%` are super convenient and readable.
- **Production code / scripts** → prefer the **standard library** (`subprocess`, `os`, `pathlib`, `timeit`, etc.) so your code runs anywhere, not just in IPython.

If you share what you’re trying to do (install packages, call a CLI, time code, run another file), I’ll show the cleanest notebook and script versions side-by-side.

---

Totally fair—here’s the crisp rule:

# The rule of thumb

- **Use `!`** when you want to run a **shell command** from a notebook cell.
    
    Think: “what I’d type in Terminal/PowerShell.”
    
- **Use `%` (or `%%`)** when you want an **IPython/Jupyter feature** (a “magic”).
    
    Think: “helper commands that _augment_ Python.”
    

They only work in IPython/Jupyter. In plain Python, both are syntax errors.

---

## What goes where?

### `!` — shell command

```python
!ls -la
!python script.py arg1
!grep -n "TODO" *.py
files = !ls         # capture output as a list of lines
name = "data.csv"
!wc -l {name}       # use Python vars with {expr}

```

### `%` — line magic (single line)

```python
%pwd                 # print working directory
%cd src              # change notebook cwd
%timeit f(x)         # benchmark
%env API_KEY=abc     # set env var for this kernel
%run script.py       # run a .py in *this* kernel
%pip install numpy   # install into the current kernel (prefer over !pip)

```

### `%%` — cell magic (whole cell)

```python
%%time               # time the whole cell
for _ in range(1000000):
    pass

%%bash               # run the *whole cell* as bash
echo "hello"
uname -a

```

---

## Quick decision guide

- “I want to call git/pip/ffmpeg/curl/ls/whoami” → **`!`**
- “I want to install a package _into this kernel_” → **`%pip`** (not `!pip`)
- “I want to time, cd, run another .py, set env vars” → **`%...` magic**
- “I want the whole cell to be bash/Ruby/SQL” → **`%%...` cell magic**
- “I’m in a normal Python script/REPL” → **neither** (`subprocess`, `os`, `timeit`, etc.)

---

## Pure-Python equivalents (for scripts/production)

- `!cmd args` → `subprocess.run(["cmd","args"])`
- `%cd dir` → `os.chdir("dir")`
- `%timeit expr` → `timeit.timeit("expr", globals=globals(), number=...)`
- `%run file.py` → `runpy.run_path("file.py")`
- `%env VAR=val` → `os.environ["VAR"]="val"`

---

## Common pitfalls

- `!pip` may install into the **wrong environment**; prefer **`%pip`** in notebooks.
- `!` commands run in a **subshell**; env changes there (like `export FOO=1`) don’t persist to Python. Use `%env FOO=1`.
- On Windows PowerShell, shell syntax differs (e.g., `dir` vs `ls`); `!` obeys whatever shell IPython is using.
- In Markdown cells, `$...$` is **LaTeX math**, not shell.

If you tell me what you’re trying to do (install packages, run a CLI, time code, change dirs), I’ll show the exact `!` vs `%` command to use—and the plain Python alternative.

---

Great mental model:

# Rule of thumb

- **Use `%` (line magic)** when a **single line** is enough.
- **Use `%%` (cell magic)** when the magic should apply to the **entire cell** (multiple lines / a block), or when you want to **change the cell’s language or behavior**.

They work only in IPython/Jupyter—not in plain Python.

---

## When to use `%` (line magic)

- One-shot helpers on a single line.
    
- Typical examples:
    
    ```python
    %pwd                 # show working directory
    %cd src              # change directory
    %timeit f(x)         # benchmark a single expression/call
    %pip install numpy   # install into the *current kernel*
    %run script.py       # run a .py file in this kernel
    %env API_KEY=abc     # set an env var for Python
    
    ```
    
- Think: “I’d write just one command.”
    

## When to use `%%` (cell magic)

- You need a **block** (many lines) or want to switch the **cell mode**.
    
- Typical examples:
    
    ```python
    %%time                # time the whole cell
    big_setup()
    run_benchmark()
    
    %%timeit              # time a multi-line snippet many times
    for _ in range(1000):
        f(x)
    
    %%bash                # run the whole cell as Bash
    echo "hello"
    uname -a
    
    %%writefile script.py # write the cell contents to a file
    print("hello from a file")
    
    %%capture cap         # capture stdout/stderr from the whole cell
    print("no notebook output")
    
    %%html
    <b>render raw HTML for this cell</b>
    
    ```
    
- Think: “I want this magic to govern **everything in the cell**.”
    

---

## Quick decision guide

- One-liner timing/help/utility → **`%`**
- Multi-line timing or setup+action → **`%%time` / `%%timeit`**
- Run several shell commands → **`%%bash`** (or `%%sh`)
- Generate a file from a block → **`%%writefile`**
- Render or transform the whole cell (HTML/markdown/latex) → **`%%html`**, **`%%markdown`**, **`%%latex`**

---

## Tips & pitfalls

- Inside notebooks, prefer **`%pip`** over `!pip` so installs go into the current kernel.
    
- `%` magics usually don’t have to be first on the line (but they are a single line).
    
- `%%` magics must be the **first thing** in the cell.
    
- To see what you have available:
    
    ```python
    %lsmagic
    
    ```
    
- Many magics have **only one form** (e.g., `%%bash` is cell-only), while some offer both (`%timeit` and `%%timeit`).
    

If you tell me what you’re trying to do (e.g., benchmark a multi-line block vs a single function call, run a few shell commands, write a file), I’ll show the exact `%` or `%%` to use.